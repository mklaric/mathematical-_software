{"kernelspec":{"display_name":"Anaconda (Python 3)","language":"python","name":"anaconda3"},"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.5.1"}}
{"cell_type":"markdown","metadata":{},"source":" <br> <center><font color=\"#000099\" size=7 >Algoritmi za sortiranje </font></center>\n\n---\n<br>"}
{"cell_type":"markdown","metadata":{},"source":"<center><font color=\"#0059b3\" size=6>Ideja </font></center>"}
{"cell_type":"markdown","metadata":{},"source":"<center><font size=3>\n<li> Implementirati već poznate nam algoritme za sortiranje\n<li> Razmisliti o načinu ubrzanja koda i primijeniti ga, te testirati brzine\n<li> Promotriti postupak izvođenja koraka algoritama</li>\n</font> </center>"}
{"cell_type":"markdown","metadata":{},"source":"<br><font color=\"#004080\" size=6>Insertion sort</font><br>"}
{"cell_type":"markdown","metadata":{},"source":"* Podsjeća nas na metodu koju koriste kartaši u sortiranju svojih karata\n* Svrstavamo ga u algoritme za sortiranje koji se svode na umetanje novog elementa u već sortirani niz elemenata\n\n* Gradi završni sortirani niz jedan po jedan element"}
{"cell_type":"code","execution_count":95,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"import pylab\nimport time\nimport random\nimport copy as cp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom random import shuffle\nfrom IPython.display import display,clear_output\n"}
{"cell_type":"markdown","metadata":{},"source":"Implementacija insertion sorta:"}
{"cell_type":"code","execution_count":96,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"def insertion_sort(a):\n    for i in range (len(a)):\n        j=i\n        while(j>0 and a[j-1]> a[j]):\n            a[j-1],a[j]=a[j], a[j-1]\n            j-=1\n    return a"}
{"cell_type":"markdown","metadata":{},"source":"Uzet ćemo dvije liste. \nJednu listu sa nasumično odabranih 20 cijelih brojeva. \nDruga lista će se sastojati od istih elemenata kao i prva samo neće biti ponavljajućih elemenata i biti će sortirana. Prvu ćemo zatim sortirati sa insertion sortom."}
{"cell_type":"code","execution_count":97,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::2aaa6101-ef80-4a37-ad43-0b528c761743","text/plain":"<matplotlib.figure.Figure at 0x7f47bc42e6a0>"},"metadata":{},"output_type":"display_data"}],"source":"lista=np.random.randint(1,high=20, size=20)\nlista_unique=np.unique(lista)\n\nx=np.arange(0,len(lista),1 )\nx_unique=np.arange(0,len(lista_unique), 1)\n\nfig, axes = plt.subplots(1, 2, figsize=(20,6), frameon=False)\nfor ax in axes: ax.patch.set_facecolor('None'), ax.tick_params(color='black')\naxes[0].bar(x, lista, align=\"center\", width=0.5, alpha=0.2)\naxes[0].set_title('A= Nesortirana lista nausmičnih 20 integera', fontsize=20)\naxes[0].set_xlim(-1, 20),axes[0].set_ylim(0, 20);\naxes[1].bar(x_unique, lista_unique, align=\"center\", width=0.5, alpha=0.4)\naxes[1].set_title('B= Sortirana lista sa \"unique\" bez ponavljajućih elemenata',fontsize=20)\naxes[1].set_xlim(-1, len(lista_unique)),axes[1].set_ylim(0, 20);\n"}
{"cell_type":"code","execution_count":98,"metadata":{"collapsed":false,"scrolled":true,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::ccfa58cc-c464-4030-8880-1471fd6407fb","text/plain":"<matplotlib.figure.Figure at 0x7f47bc8cb080>"},"metadata":{},"output_type":"display_data"}],"source":"sortirana_lista=insertion_sort(lista)\n\n# uzeti ćemo listu sa ponavljajućim elementima koju smo sortirali, i iz nje izvaditi ponavljajuće elemente\n# no ostaviti ćemo ju u istom poretku kakvu smo i uzeli(nećemo koristiti sort od funkcije unique)\n\nsortirana_lista_unique, index = np.unique(sortirana_lista, return_index=True)\nA_finalna= sortirana_lista_unique[index.argsort()]\n\n\nfig, axes = plt.subplots(1, 2, figsize=(20,6))\naxes[0].bar(x, sortirana_lista, align=\"center\", width=0.5, alpha=0.2)\naxes[0].set_title('A - sortirana', fontsize=20)\naxes[0].set_xlim(-1, 20), axes[0].set_ylim(0, 20)\naxes[1].bar(x_unique, A_finalna, align=\"center\", width=0.5, alpha=0.4)\naxes[1].set_title('A - sortirana, bez ponavljajućih elemenata', fontsize=20)\naxes[1].set_xlim(-1, len(lista_unique)),axes[1].set_ylim(0, 20);\n\n"}
{"cell_type":"markdown","metadata":{},"source":"Vidimo da se slike u drugom stupcu podudaraju, no možemo još i računski provjeriti je li A-sortirana, bez ponavljajućih elemenata jednaka listi B."}
{"cell_type":"code","execution_count":99,"metadata":{"collapsed":false,"scrolled":true,"trusted":true},"outputs":[{"data":{"text/plain":"True"},"execution_count":99,"metadata":{},"output_type":"execute_result"}],"source":"np.array_equiv(A_finalna,lista_unique)"}
{"cell_type":"markdown","metadata":{},"source":"### Pokažimo kako insertion sort radi:"}
{"cell_type":"markdown","metadata":{},"source":"<font size=3>U svakom prolasku uzimamo prvi idući element iz nesortiranog dijela liste, uspoređujemo ga sa elementima ispred sebe i tako ga ubacujemo na pravo mjesto, u sortirani dio liste.</font>\n"}
{"cell_type":"code","execution_count":101,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::0fe74542-2074-4f1d-a87a-7ebc64f2cae4","text/plain":"<matplotlib.figure.Figure at 0x7f47bc83f898>"},"metadata":{},"output_type":"display_data"}],"source":"def insertion_sort_anim(a):\n    \n    fig=plt.figure()\n    fig.set_size_inches(12,6)\n    length=len(a)\n    \n    cmap = plt.get_cmap('viridis')\n    indices = np.linspace(0, cmap.N, 10)\n    x = range(length)\n    width=0.4\n   \n      \n    for i in range (len(a)):\n        j=i\n        while(j>0 and a[j-1]> a[j]):\n            #slika prije zamjene\n            plt.cla()\n            colors=[]\n            for k in range(length):\n                        if (k==j) : colors.append(cmap(int(indices[5])))\n                        elif(k==i+1): colors.append(cmap(int(indices[0])))\n                        else: colors.append(cmap(int(indices[8])))\n            plt.bar(x,a, width=width,color=colors,edgecolor = \"white\")\n            display(fig)\n            clear_output(wait=True)\n            time.sleep(0.005)\n            \n            a[j-1],a[j]=a[j], a[j-1]\n            \n            #slika nakon zamjene\n            plt.cla()\n            colors=[]\n            for k in range(length):\n                        if (k==j-1) : colors.append(cmap(int(indices[5])))\n                        elif(k==i+1): colors.append(cmap(int(indices[0])))\n                        else: colors.append(cmap(int(indices[8])))\n            plt.bar(x,a, width=width,color=colors,edgecolor = \"white\")\n            display(fig)\n            clear_output(wait=True)\n            time.sleep(0.005)\n            j-=1\n            \n    return a\n\na=random.sample(range(1, 16), 15)\ninsertion_sort_anim(a);"}
{"cell_type":"markdown","metadata":{},"source":"<br><font size=4>Ako želite i sami isprobati radi li insertion sort na različitim duljinama niza</font>"}
{"cell_type":"code","execution_count":102,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::986c64be-7593-4537-af9c-3add9c9ac4d8","text/plain":"<matplotlib.figure.Figure at 0x7f47bc0b0cf8>"},"metadata":{},"output_type":"display_data"}],"source":"from ipywidgets import interact, fixed\ndef insertion_sort(n):\n    a=random.sample(range(1, n+1), n)\n    \n    x=np.arange(0,n,1 )\n    fig, axes = plt.subplots(1, 2, figsize=(20,6))\n    axes[0].bar(x, a, align=\"center\", width=0.5, alpha=0.450, edgecolor=\"white\", color=\"#23BA60\")\n    axes[0].set_title('nasumična lista A n brojeva', fontsize=20)\n    axes[0].set_xlim(-1, n), axes[0].set_ylim(0, n)\n       \n    for i in range (n):\n        j=i\n        while(j>0 and a[j-1]> a[j]):\n            a[j-1],a[j]=a[j], a[j-1]\n            j-=1\n            \n    axes[1].bar(x, a, align=\"center\", width=0.5, alpha=1, edgecolor=\"white\", color=\"#1F6655\")\n    axes[1].set_title('A - sortirana', fontsize=20)\n    axes[1].set_xlim(-1, n),axes[1].set_ylim(0,n);\n    \ninteract(insertion_sort, n=(10,50));"}
{"cell_type":"markdown","metadata":{},"source":"<br><font color=\"#004080\" size=6>Bubble sort</font><br>"}
{"cell_type":"markdown","metadata":{},"source":"<font size=3>Bubble-sort je (dokazano) najbrži algoritam za sortiranje u okviru određenih okolnosti.<br>  \n\nPostao je izvorno dobro poznat prije svega jer je to jedan od prvih algoritama (bilo koje vrste), koji se rigorozno analizirao, te je pronađen dokaz da je optimalan unutar svojih ograničenih okolnosti.<br>\nZamislite datoteke koje su pohranjene na zapisnoj vrpci, te tako malo radnu memoriju u koju možete učitati samo dva zapisa u u bilo kojem trenutku.<br><br>\n\nPremotavanje vrpce je toliko sporo da je slučajni pristup podacima unutar datoteke jako nepraktičan.\nDakle, želimo obraditi zapise sekvencijalno, ne više od dva u isto vrijeme.<br><br>\n\nKada se još radilo sa zapisnim vrpcama,a strojevi su imali tek nekoliko tisuća riječi/bajta RAM-a, shvatilo se da je to dovoljno često korištena pojava o kojoj se isplati istraživati.<br>\nTakvih okolnosti sada više nema, pa istraživanje performansa Bubble-sorta gotovo uopće nema smisla.\nNo, u današnje vrijeme kada nas se uči Bubble-sortu uopće se ne spominje optimalni slučaj i njegova povijest, pa kada bi se netko i našao u pravoj situaciji, vjerojatno ne bi znao iskoristiti Bubble-sort.</font>\n"}
{"cell_type":"markdown","metadata":{},"source":"### Promotriti ćemo Bubble sort i njegove implementacije."}
{"cell_type":"code","execution_count":103,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"def bubblesort(a):\n    length = len(a)\n    for i in range(length):\n        for j in range(1, length):\n            if a[j] < a[j-1]:\n                a[j-1], a[j] = a[j], a[j-1]\n    return a"}
{"cell_type":"markdown","metadata":{},"source":"<font size=4>Prvo pogledajmo kako on uopće radi: </font>"}
{"cell_type":"code","execution_count":104,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/html":"<iframe width=\"1100\" height=\"500\" frameborder=\"0\" src=\"https://goo.gl/vJGq08\"> </iframe>","text/plain":"<IPython.core.display.HTML object>"},"execution_count":104,"metadata":{},"output_type":"execute_result"}],"source":"from IPython.display import HTML\nHTML('<iframe width=\"1100\" height=\"500\" frameborder=\"0\" src=\"https://goo.gl/vJGq08\"> </iframe>')"}
{"cell_type":"markdown","metadata":{},"source":"<br><font size=3> U sljedećoj animaciji prikazuje se jedan prolazak Bubble sorta,\ngdje se vidi kako se u jednom trenutku zamijenjuju dvije vrijednosti.</font>"}
{"cell_type":"code","execution_count":105,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::9ae212c8-3f09-4986-995f-3007c24ef272","text/plain":"<matplotlib.figure.Figure at 0x7f47bc18e3c8>"},"metadata":{},"output_type":"display_data"}],"source":"def bubblesort_anim(a):\n    length=len(a)\n    x = range(length)\n    width=0.35\n    zamjena = True\n    fig=plt.figure()\n    cmap = plt.get_cmap('inferno')\n    indices = np.linspace(0, cmap.N, 20)\n   \n    for i in range(length-1):\n        if a[i] > a[i+1]:\n            colors = []\n            for j in range(length):\n                if (j == i) : colors.append(cmap(int(indices[3])))\n                elif(j==i+1): colors.append(cmap(int(indices[7])))\n                else: colors.append(cmap(int(indices[17])))\n            fig.set_size_inches(12,6)\n            plt.cla()\n            plt.bar(x,a, width=width, color=colors, edgecolor=\"white\", alpha=0.85)\n            display(fig)\n            clear_output(wait=True)\n            time.sleep(0.10)\n            \n            a[i+1], a[i] = a[i], a[i+1] # swap\n            zamjena = True\n            \n            colors = []\n            for j in range(length):\n                if (j == i) : colors.append(cmap(int(indices[7])))\n                elif(j==i+1): colors.append(cmap(int(indices[3])))\n                else: colors.append(cmap(int(indices[17])))\n            fig.set_size_inches(12,6)\n            plt.cla()\n            plt.bar(x,a, width=width, color=colors, edgecolor=\"white\", alpha=0.85)\n            display(fig)\n            clear_output(wait=True)\n            time.sleep(0.06)\n                 \na = list(range(1,21))\nshuffle(a)\nbubblesort_anim(a)"}
{"cell_type":"markdown","metadata":{},"source":"<font size=3>Zatim stavljamo poboljšanu verziju, koja se brine za to da sortiranje stane čim nije potrebno više zamjena</font>"}
{"cell_type":"code","execution_count":106,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"def bubblesort_improved(a):\n    length = len(a)\n    swapped = 1\n    for i in range(length):\n        if swapped: \n            swapped = 0\n            for ele in range(length-i-1):\n                if a[ele] > a[ele + 1]:\n                    temp = a[ele + 1]\n                    a[ele + 1] = a[ele]\n                    a[ele] = temp\n                    swapped = 1\n    return a"}
{"cell_type":"markdown","metadata":{},"source":"Želimo provjeriti da su liste koje dobijemo sa običnim i poboljšanim bubble-sortom iste:"}
{"cell_type":"code","execution_count":107,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"Oba bubblesorta daju isti rezultat\n"}],"source":"l = [random.randint(1,1000) for num in range(1, 1000)]\nl_sortirana = sorted(l)\n#za funkcije bubblesort i bubblesort_improved provjeravamo\nfor f in [bubblesort, bubblesort_improved]: \n    assert(l_sortirana  == f(cp.copy(l))), \"ne radi\"\nprint(\"Oba bubblesorta daju isti rezultat\")\n"}
{"cell_type":"markdown","metadata":{},"source":"<br>\n### Usporedimo brzine običnog i poboljšanog bubble-sorta"}
{"cell_type":"markdown","metadata":{},"source":"* sa manjom listom"}
{"cell_type":"code","execution_count":108,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"The slowest run took 6.87 times longer than the fastest. This could mean that an intermediate result is being cached.\n1000 loops, best of 3: 1.04 ms per loop\nThe slowest run took 74.95 times longer than the fastest. This could mean that an intermediate result is being cached.\n100000 loops, best of 3: 13.5 µs per loop\n"}],"source":"l_mala = [random.randint(1,100) for num in range(1, 100)]\nl_mala_cp = cp.copy(l_mala)\n\n%timeit bubblesort(l_mala)\n%timeit bubblesort_improved(l_mala_cp)"}
{"cell_type":"markdown","metadata":{},"source":"* sa većom listom"}
{"cell_type":"code","execution_count":109,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"1 loop, best of 3: 16.8 s per loop\nThe slowest run took 7073.17 times longer than the fastest. This could mean that an intermediate result is being cached.\n1 loop, best of 3: 1.78 ms per loop\n"}],"source":"l_velika = [random.randint(1,10000) for num in range(1, 10000)]\nl_velika_cp = cp.copy(l_velika)\n\n%timeit bubblesort(l_velika)\n%timeit bubblesort_improved(l_velika_cp)"}
{"cell_type":"markdown","metadata":{},"source":"<br><font size=4>Iduća animacija prikazuje korake nakon svakog prolaska poljem </font>"}
{"cell_type":"code","execution_count":110,"metadata":{"collapsed":false,"scrolled":true,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::9d64180d-6ccc-4c98-9dd8-4063fe7650d0","text/plain":"<matplotlib.figure.Figure at 0x7f47bc187a20>"},"metadata":{},"output_type":"display_data"}],"source":"def bubblesort_anim(a):\n    length=len(a)\n    x = range(length)    \n    zamjena = True\n    fig, ax = plt.subplots()\n    while zamjena: \n        zamjena = False\n        for i in range(length-1):\n            if a[i] > a[i+1]:\n                a[i+1], a[i] = a[i], a[i+1] #ovdje radimo zamjenu\n                zamjena = True\n        ax.cla() \n        ax.plot(x,a,'k.',markersize=8)\n        display(fig)\n        clear_output(wait=True)\n        time.sleep(0.003)\n                 \na = list(range(100))\nshuffle(a)\nbubblesort_anim(a)"}
{"cell_type":"markdown","metadata":{},"source":"<br><br><font color=\"#004080\" size=6>Quicksort</font>"}
{"cell_type":"markdown","metadata":{},"source":"<br><font size=4>\n* Koristi podijeli-pa-vladaj pristup\n* U svrhu sortiranja poziva sam sebe\n* Da bi sortirali polje podijelimo ga na dva manja dijela i sortiramo ih rekurzivno</font>"}
{"cell_type":"code","execution_count":111,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"def quicksort(l,u,a):\n    if(l >= u): return\n    m = l;\n    for i in range(l + 1, u + 1):\n        if (a[i] < a[l]): \n            a[++m], a[i] = a[i], a[++m]\n    a[l], a[m] = a[m], a[l]\n    quicksort(l, m-1,a)\n    quicksort(m+1,u,a)"}
{"cell_type":"markdown","metadata":{},"source":"<br><font size=4><center>Implementacija bržeg quicksorta</center></font>"}
{"cell_type":"markdown","metadata":{},"source":"Koristimo dvostrano particioniranje, odnosno\n* uzimamo indekse i, i jot koji su inicijalizirani na dva kraja polja koje želimo particionirati\n*  prva unutarnja petlja miče i preko manjih elemenata i staje kada naiđe na element veći od pivota\n* ruga unutarnja petlja miče jot od većih elemenata i staje kada naiđe na manji\nelement od pivota\n* glavna petlja tada testira jesu li se indeksi prekrižili\n* ako nisu mijenja im vrijednosti"}
{"cell_type":"code","execution_count":112,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"def quicksort_faster(l,u,a):\n    if(l >= u): return\n    t = a[l]; i=l; j=u+1;\n    while(1):\n        i+=1\n        j-=1\n        while (i<=u and a[i]<t): i+=1\n        while (a[j]>t) : j-=1\n        if (i>j): break\n        a[i],a[j]=a[j],a[i]\n    \n    a[l],a[j]=a[j],a[l]\n    quicksort_faster(l,j-1,a)\n    quicksort_faster(j+1,u,a)"}
{"cell_type":"markdown","metadata":{},"source":"<font size=3> Usporedba polja dobivenih sporijim i bržim quicksortom</font>"}
{"cell_type":"code","execution_count":113,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40]\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40]\n"},{"data":{"text/plain":"True"},"execution_count":113,"metadata":{},"output_type":"execute_result"}],"source":"a=random.sample(range(1, 41), 40)\na_copy= cp.copy(a)\nquicksort(0,len(a)-1,a)\nquicksort_faster(0,len(a)-1,a_copy)\n\nprint(a)\nprint(a_copy)\n\nnp.array_equiv(a,a_copy)"}
{"cell_type":"markdown","metadata":{},"source":"<font size=3> Usporedba brzina</font>"}
{"cell_type":"code","execution_count":114,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"1000 loops, best of 3: 472 µs per loop\n1000 loops, best of 3: 418 µs per loop\n"}],"source":"l_mala = [random.randint(1,100) for num in range(1, 100)]\nl_mala_cp = cp.copy(l_mala)\n\n%timeit quicksort(0, len(l_mala)-1, l_mala)\n%timeit quicksort_faster(0, len(l_mala_cp)-1, l_mala_cp)"}
{"cell_type":"markdown","metadata":{},"source":"Razlika u brzinama bi bila vidljivija na puno većim poljima"}
{"cell_type":"markdown","metadata":{},"source":"<br><font size=4>Iduća animacija prikazuje korake nakon svakog prolaska rekurzivnim potpoljima </font>"}
{"cell_type":"code","execution_count":115,"metadata":{"collapsed":false,"scrolled":true,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::bc702285-3045-477b-a2b3-bdce57b7190c","text/plain":"<matplotlib.figure.Figure at 0x7f47bc47c2b0>"},"metadata":{},"output_type":"display_data"}],"source":"fig, ax = plt.subplots()\nfig.set_size_inches(12,6)\ndef quicksort_anim(l,u,a):\n    length=len(a)\n    x = range(length)        \n    if(l >= u): return    \n    m = l;\n    for i in range(l + 1, u + 1):\n        if (a[i] < a[l]): \n            m+=1\n            a[m], a[i] = a[i], a[m]\n    a[l], a[m] = a[m], a[l]\n    \n    ax.cla(),  ax.plot(x,a,'k.',markersize=8), display(fig), clear_output(wait=True), time.sleep(0.0005)\n       \n    quicksort_anim(l, m-1,a)\n    \n    ax.cla(),  ax.plot(x,a,'k.',markersize=8), display(fig), clear_output(wait=True), time.sleep(0.0005)\n      \n    quicksort_anim(m+1,u,a)\n    \n    ax.cla(),  ax.plot(x,a,'k.',markersize=8), display(fig), clear_output(wait=True), time.sleep(0.0005)\n    \n    \n    \n\na=random.sample(range(1, 101), 100)\nquicksort_anim(0,len(a)-1,a)"}
{"cell_type":"markdown","metadata":{},"source":"<br><font size=4>Pokažimo što radi jedan prolazak kroz polje u Quicksortu sa dvostranim particioniranjem</font>"}
{"cell_type":"code","execution_count":116,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::ca7ad16d-bdff-45fb-a21a-1934eff2488c","text/plain":"<matplotlib.figure.Figure at 0x7f47bc105438>"},"metadata":{},"output_type":"display_data"}],"source":"import matplotlib.patches as mpatches\ndef quicksort_faster(l,u,a):\n    fig=plt.figure()\n    fig.set_size_inches(15,10)\n    length=len(a)\n    \n    cmap = plt.get_cmap('YlGnBu')\n    indices = np.linspace(0, cmap.N, 10)\n    \n    tamno_plava = mpatches.Patch(color=cmap(int(indices[9])))\n    tirkizna = mpatches.Patch(color=cmap(int(indices[4])))\n    plava = mpatches.Patch(color=cmap(int(indices[7])))\n    zelena = mpatches.Patch(color=cmap(int(indices[2])))\n\n    \n    fig.legend(handles=[tamno_plava, plava,tirkizna , zelena], labels=[\"pivotni element\", \"plava\",\"tirkizna\" , \"zelena\"],loc=2)\n    \n    x = range(length)\n    width=0.4\n    if(l >= u): return\n    t = a[l]; i=l; j=u+1;\n    while(1):\n        i+=1\n        j-=1\n        while (i<=u and a[i]<t): \n            i+=1\n            plt.cla()\n            colors=[]\n            for k in range(length):\n                        if (k==i) : colors.append(cmap(int(indices[7])))\n                        elif(k==l): colors.append(cmap(int(indices[9])))\n                        elif(k==j): colors.append(cmap(int(indices[4])))\n                        else: colors.append(cmap(int(indices[2])))\n            plt.bar(x,a, width=width,color=colors,edgecolor = \"none\")\n            display(fig)\n            clear_output(wait=True)\n            time.sleep(0.09)\n        \n        my_colors = [cmap(int(i)) for i in indices]\n        while (a[j]>t) :\n            j-=1\n            \n            plt.cla()\n            colors=[]\n            for k in range(length):\n                        if (k==i) : colors.append(cmap(int(indices[7])))\n                        elif(k==l): colors.append(cmap(int(indices[9])))\n                        elif (k==j):colors.append(cmap(int(indices[4])))\n                        else: colors.append(cmap(int(indices[2])))\n            plt.bar(x,a, width=width,color=colors, edgecolor = \"none\")\n            display(fig)\n            clear_output(wait=True)\n            time.sleep(0.09)\n           \n        if (i>j): break\n        a[i],a[j]=a[j],a[i]\n        \n        plt.cla()\n        colors=[]\n        for k in range(length):\n                        if (k==j) : colors.append(cmap(int(indices[7])))\n                        elif(k==l): colors.append(cmap(int(indices[9])))\n                        elif(k==i) :colors.append(cmap(int(indices[4])))\n                        else:colors.append(cmap(int(indices[2])))\n        plt.bar(x,a, width=width,color=colors,edgecolor = \"none\")\n        display(fig)\n        clear_output(wait=True)\n        time.sleep(0.09)\n    \n    fig.savefig(\"prije_zamjene_pivota.png\", dpi=200);\n    a[l],a[j]=a[j],a[l]\n    plt.cla()\n    colors=[]\n    for k in range(length):\n                    if (k==l) : colors.append(cmap(int(indices[7])))\n                    elif(k==j):colors.append(cmap(int(indices[9])))\n                    elif (k==i) :colors.append(cmap(int(indices[4])))\n                    else:colors.append(cmap(int(indices[2])))\n    plt.bar(x,a, width=width,color=colors,edgecolor = \"none\")\n    fig.savefig(\"nakon_zamjene_pivota.png\", dpi=200);\n    \n    \n    \na=random.sample(range(1, 31), 30)\nquicksort_faster(0,len(a)-1,a)"}
{"cell_type":"markdown","metadata":{},"source":"<font size=3>Tamno plava je pivotni element. Tirkizna boja ide s desna i traži prvi stupac koji je manji od pivota.\nPlava boja ide s lijeva i traži prvi element koji je veći od pivota.\nZatim se ta dva zamjenjuju.</font>"}
{"cell_type":"code","execution_count":117,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::859f0dde-d70a-4261-9032-85df24881299","text/plain":"<IPython.core.display.Image object>"},"metadata":{"image/png":{"height":200,"width":400}},"output_type":"display_data"},{"data":{"image/png":"smc-blob::2a3809de-8429-4b7d-912f-ce3278c27097","text/plain":"<IPython.core.display.Image object>"},"metadata":{"image/png":{"height":200,"width":400}},"output_type":"display_data"}],"source":"from IPython.display import Image,display_png\nx=Image(filename='prije_zamjene_pivota.png', width=400, height=200) \ny=Image(filename='nakon_zamjene_pivota.png',  width=400, height=200) \ndisplay(x,y)"}
{"cell_type":"markdown","metadata":{},"source":"<font size=3>Nakon što se provede prvi prolazak kroz polje, desno od plavog stupca uključivši njega su svi stupci veći od pivotnog elementa, a lijevo od tirkiznog stupca su svi manji od pivotnog elementa. [slika1]<br>\nZatim se pivotni element zamjenjuje sa manjim od(plavi, tirkizni) [slika2], te se quicksort poziva rekurzivno na dva manja potpolja,\njedno lijevo od pivotnog elementa, drugo desno od pivotnog elementa.</font>"}
{"cell_type":"markdown","metadata":{},"source":"<br><center><font color=\"#0059b3\" size=4>Za kraj pogledajmo složenosti ovih algoritama </font></center>"}
{"cell_type":"markdown","metadata":{},"source":"<table >\n  <thead >\n    <tr>\n      <th>Algoritam</th>\n      <th colspan=\"3\"><center>Vremenska složenost</center></th>\n      <th>Prostorna složenost</th>\n    </tr>\n    <tr>\n      <th></th>\n      <th bgcolor=\"#b3e0ff\">Najbolja</th>\n      <th bgcolor=\"#4db8ff\">Prosječna</th>  \n      <th bgcolor=\"#0099ff\">Najgora</th>     \n      <th bgcolor=\"#adebeb\"><center>Najgora</center></th>            \n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td bgcolor=\"#ffeb99\">Quicksort</td>\n      <td><code><center>O(nlog(n))</center></code></td>\n      <td><code><center>O(nlog(n))</center></code></td>\n      <td><code><center>O(n^2)</center></code></td>\n      <td><code><center>O(log(n))</center></code></td>\n    </tr>\n   \n    <tr>\n      <td bgcolor=\"#ffcc66\">Bubble Sort</td>\n      <td><code ><center>O(n)</center></code></td>\n      <td><code ><center>O(n^2)</center></code></td>\n      <td><code ><center>O(n^2)</center></code></td>\n      <td><code ><center>O(1)</center></code></td>\n    </tr>\n    <tr>\n      <td bgcolor=\"#ff9966\">Insertion Sort</td>\n      <td><code><center>O(n)</center></code></td>\n      <td><code><center>O(n^2)</center></code></td>\n      <td><code><center>O(n^2)</center></code></td>\n      <td><code><center>O(1)</center></code></td>\n    </tr>\n    \n  </tbody>\n</table>"}
{"cell_type":"markdown","metadata":{},"source":"Nacrtati ćemo najbolje i prosječne vremenske složenosti ovih algoritama"}
{"cell_type":"code","execution_count":118,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::74e16269-fc78-4555-8b5c-fce3099fc80d","text/plain":"<matplotlib.figure.Figure at 0x7f47bc2c62b0>"},"metadata":{},"output_type":"display_data"}],"source":"n = np.linspace(0.1,100)\nfig, axes = plt.subplots()\nfig.set_size_inches(12,6)\naxes.set_xlabel('n') \naxes.set_ylabel('vremenska složenost')\naxes.set_title('Vremenske složenosti')\naxes.set_xlim(0,100),axes.set_ylim(-1, 400);\n\nline1, =axes.plot(n, n*np.log(n), 'g-', label=\"Quicksort\");\nline2, =axes.plot(n, n, 'g--',linewidth=2, label=\"Bubble Sort\");\nline3, =axes.plot(n, n, 'g*',linewidth=1,label=\"Insertion Sort\");\nfirst_legend = plt.legend(handles=[line1, line2,line3],  loc=7, title=\"Najbolje v.s.\", fontsize=13)\nax = plt.gca().add_artist(first_legend)\n\nline4, =axes.plot(n, n*np.log(n), 'b*', label=\"Quicksort\");\nline5, =axes.plot(n, n**2, 'r--',linewidth=2, label=\"Bubble Sort\");\nline6, =axes.plot(n, n**2, 'r*',linewidth=1,label=\"Insertion Sort\");\nplt.legend(handles=[line4,line5,line6], loc=9, title= \"Prosječne v.s.\", fontsize=13);"}
{"cell_type":"markdown","metadata":{},"source":"<br><center><font color=\"#0059b3\" size=6>Zaključak </font></center>"}
{"cell_type":"markdown","metadata":{},"source":"<center><font size=3>\n<li>Promotrili smo neke osnovne algoritme za sortiranje, i princip njihova izvođenja</li><br>\n<li>Insertion sort je jednostavan kod koji je dovoljno brz na malom broju elemenata za\nsortiranje</li><br>\n<li> Bubble sort je idealan samo za pojašnjeni poseban slučaj :)</li><br>\n<li> Quicksort svojim podijeli-pa-vladaj pristupom ima najbolju prosječnu vremensku složenost pa je najčešće i najbolji za korištenje</li><br>\n<li> Postoje još mnogi drugi razrađeni algoritmi za sortiranje </font> </center>"}